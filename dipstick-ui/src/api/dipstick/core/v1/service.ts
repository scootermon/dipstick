// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "dipstick/core/v1/service.proto" (package "dipstick.core.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { EntityMeta } from "./entity";
import { LogEvent } from "./logging";
import { LogConfig } from "./logging";
/**
 * Shutdown request
 *
 * @generated from protobuf message dipstick.core.v1.ShutdownRequest
 */
export interface ShutdownRequest {}
/**
 * Shutdown response
 *
 * @generated from protobuf message dipstick.core.v1.ShutdownResponse
 */
export interface ShutdownResponse {}
/**
 * Version request
 *
 * @generated from protobuf message dipstick.core.v1.VersionRequest
 */
export interface VersionRequest {}
/**
 * Version response
 *
 * @generated from protobuf message dipstick.core.v1.VersionResponse
 */
export interface VersionResponse {
  /**
   * The version of the server.
   *
   * @generated from protobuf field: string version = 1;
   */
  version: string;
}
/**
 * LogConfig request
 *
 * @generated from protobuf message dipstick.core.v1.LogConfigRequest
 */
export interface LogConfigRequest {
  /**
   * The new logging configuration.
   * If empty, the current configuration is returned.
   *
   * @generated from protobuf field: dipstick.core.v1.LogConfig config = 1;
   */
  config?: LogConfig;
}
/**
 * LogConfig response
 *
 * @generated from protobuf message dipstick.core.v1.LogConfigResponse
 */
export interface LogConfigResponse {
  /**
   * The current logging configuration.
   *
   * @generated from protobuf field: dipstick.core.v1.LogConfig config = 1;
   */
  config?: LogConfig;
}
/**
 * LogSubscribe request
 *
 * @generated from protobuf message dipstick.core.v1.LogSubscribeRequest
 */
export interface LogSubscribeRequest {}
/**
 * LogSubscribe response
 *
 * @generated from protobuf message dipstick.core.v1.LogSubscribeResponse
 */
export interface LogSubscribeResponse {
  /**
   * A log event.
   *
   * @generated from protobuf field: dipstick.core.v1.LogEvent event = 1;
   */
  event?: LogEvent;
}
/**
 * ListEntities request
 *
 * @generated from protobuf message dipstick.core.v1.ListEntitiesRequest
 */
export interface ListEntitiesRequest {}
/**
 * ListEntities response
 *
 * @generated from protobuf message dipstick.core.v1.ListEntitiesResponse
 */
export interface ListEntitiesResponse {
  /**
   * The list of entities.
   *
   * @generated from protobuf field: repeated dipstick.core.v1.EntityMeta entities = 1;
   */
  entities: EntityMeta[];
}
/**
 * ForceRemoveAllEntities request
 *
 * @generated from protobuf message dipstick.core.v1.ForceRemoveAllEntitiesRequest
 */
export interface ForceRemoveAllEntitiesRequest {}
/**
 * ForceRemoveAllEntities response
 *
 * @generated from protobuf message dipstick.core.v1.ForceRemoveAllEntitiesResponse
 */
export interface ForceRemoveAllEntitiesResponse {}
// @generated message type with reflection information, may provide speed optimized methods
class ShutdownRequest$Type extends MessageType<ShutdownRequest> {
  constructor() {
    super("dipstick.core.v1.ShutdownRequest", []);
  }
  create(value?: PartialMessage<ShutdownRequest>): ShutdownRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ShutdownRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ShutdownRequest,
  ): ShutdownRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ShutdownRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.ShutdownRequest
 */
export const ShutdownRequest = new ShutdownRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShutdownResponse$Type extends MessageType<ShutdownResponse> {
  constructor() {
    super("dipstick.core.v1.ShutdownResponse", []);
  }
  create(value?: PartialMessage<ShutdownResponse>): ShutdownResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ShutdownResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ShutdownResponse,
  ): ShutdownResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ShutdownResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.ShutdownResponse
 */
export const ShutdownResponse = new ShutdownResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VersionRequest$Type extends MessageType<VersionRequest> {
  constructor() {
    super("dipstick.core.v1.VersionRequest", []);
  }
  create(value?: PartialMessage<VersionRequest>): VersionRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<VersionRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VersionRequest,
  ): VersionRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: VersionRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.VersionRequest
 */
export const VersionRequest = new VersionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VersionResponse$Type extends MessageType<VersionResponse> {
  constructor() {
    super("dipstick.core.v1.VersionResponse", [
      { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<VersionResponse>): VersionResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.version = "";
    if (value !== undefined)
      reflectionMergePartial<VersionResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VersionResponse,
  ): VersionResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string version */ 1:
          message.version = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: VersionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string version = 1; */
    if (message.version !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.version);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.VersionResponse
 */
export const VersionResponse = new VersionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogConfigRequest$Type extends MessageType<LogConfigRequest> {
  constructor() {
    super("dipstick.core.v1.LogConfigRequest", [
      { no: 1, name: "config", kind: "message", T: () => LogConfig },
    ]);
  }
  create(value?: PartialMessage<LogConfigRequest>): LogConfigRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<LogConfigRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogConfigRequest,
  ): LogConfigRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dipstick.core.v1.LogConfig config */ 1:
          message.config = LogConfig.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.config,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LogConfigRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* dipstick.core.v1.LogConfig config = 1; */
    if (message.config)
      LogConfig.internalBinaryWrite(
        message.config,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.LogConfigRequest
 */
export const LogConfigRequest = new LogConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogConfigResponse$Type extends MessageType<LogConfigResponse> {
  constructor() {
    super("dipstick.core.v1.LogConfigResponse", [
      { no: 1, name: "config", kind: "message", T: () => LogConfig },
    ]);
  }
  create(value?: PartialMessage<LogConfigResponse>): LogConfigResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<LogConfigResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogConfigResponse,
  ): LogConfigResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dipstick.core.v1.LogConfig config */ 1:
          message.config = LogConfig.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.config,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LogConfigResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* dipstick.core.v1.LogConfig config = 1; */
    if (message.config)
      LogConfig.internalBinaryWrite(
        message.config,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.LogConfigResponse
 */
export const LogConfigResponse = new LogConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogSubscribeRequest$Type extends MessageType<LogSubscribeRequest> {
  constructor() {
    super("dipstick.core.v1.LogSubscribeRequest", []);
  }
  create(value?: PartialMessage<LogSubscribeRequest>): LogSubscribeRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<LogSubscribeRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogSubscribeRequest,
  ): LogSubscribeRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: LogSubscribeRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.LogSubscribeRequest
 */
export const LogSubscribeRequest = new LogSubscribeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogSubscribeResponse$Type extends MessageType<LogSubscribeResponse> {
  constructor() {
    super("dipstick.core.v1.LogSubscribeResponse", [
      { no: 1, name: "event", kind: "message", T: () => LogEvent },
    ]);
  }
  create(value?: PartialMessage<LogSubscribeResponse>): LogSubscribeResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<LogSubscribeResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogSubscribeResponse,
  ): LogSubscribeResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dipstick.core.v1.LogEvent event */ 1:
          message.event = LogEvent.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.event,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LogSubscribeResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* dipstick.core.v1.LogEvent event = 1; */
    if (message.event)
      LogEvent.internalBinaryWrite(
        message.event,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.LogSubscribeResponse
 */
export const LogSubscribeResponse = new LogSubscribeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesRequest$Type extends MessageType<ListEntitiesRequest> {
  constructor() {
    super("dipstick.core.v1.ListEntitiesRequest", []);
  }
  create(value?: PartialMessage<ListEntitiesRequest>): ListEntitiesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ListEntitiesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListEntitiesRequest,
  ): ListEntitiesRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ListEntitiesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.ListEntitiesRequest
 */
export const ListEntitiesRequest = new ListEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListEntitiesResponse$Type extends MessageType<ListEntitiesResponse> {
  constructor() {
    super("dipstick.core.v1.ListEntitiesResponse", [
      {
        no: 1,
        name: "entities",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => EntityMeta,
      },
    ]);
  }
  create(value?: PartialMessage<ListEntitiesResponse>): ListEntitiesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.entities = [];
    if (value !== undefined)
      reflectionMergePartial<ListEntitiesResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListEntitiesResponse,
  ): ListEntitiesResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated dipstick.core.v1.EntityMeta entities */ 1:
          message.entities.push(
            EntityMeta.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListEntitiesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated dipstick.core.v1.EntityMeta entities = 1; */
    for (let i = 0; i < message.entities.length; i++)
      EntityMeta.internalBinaryWrite(
        message.entities[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.ListEntitiesResponse
 */
export const ListEntitiesResponse = new ListEntitiesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForceRemoveAllEntitiesRequest$Type extends MessageType<ForceRemoveAllEntitiesRequest> {
  constructor() {
    super("dipstick.core.v1.ForceRemoveAllEntitiesRequest", []);
  }
  create(
    value?: PartialMessage<ForceRemoveAllEntitiesRequest>,
  ): ForceRemoveAllEntitiesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ForceRemoveAllEntitiesRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ForceRemoveAllEntitiesRequest,
  ): ForceRemoveAllEntitiesRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ForceRemoveAllEntitiesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.ForceRemoveAllEntitiesRequest
 */
export const ForceRemoveAllEntitiesRequest =
  new ForceRemoveAllEntitiesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ForceRemoveAllEntitiesResponse$Type extends MessageType<ForceRemoveAllEntitiesResponse> {
  constructor() {
    super("dipstick.core.v1.ForceRemoveAllEntitiesResponse", []);
  }
  create(
    value?: PartialMessage<ForceRemoveAllEntitiesResponse>,
  ): ForceRemoveAllEntitiesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ForceRemoveAllEntitiesResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ForceRemoveAllEntitiesResponse,
  ): ForceRemoveAllEntitiesResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ForceRemoveAllEntitiesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.core.v1.ForceRemoveAllEntitiesResponse
 */
export const ForceRemoveAllEntitiesResponse =
  new ForceRemoveAllEntitiesResponse$Type();
/**
 * @generated ServiceType for protobuf service dipstick.core.v1.CoreService
 */
export const CoreService = new ServiceType("dipstick.core.v1.CoreService", [
  { name: "Shutdown", options: {}, I: ShutdownRequest, O: ShutdownResponse },
  { name: "Version", options: {}, I: VersionRequest, O: VersionResponse },
  { name: "LogConfig", options: {}, I: LogConfigRequest, O: LogConfigResponse },
  {
    name: "LogSubscribe",
    serverStreaming: true,
    options: {},
    I: LogSubscribeRequest,
    O: LogSubscribeResponse,
  },
  {
    name: "ListEntities",
    options: {},
    I: ListEntitiesRequest,
    O: ListEntitiesResponse,
  },
  {
    name: "ForceRemoveAllEntities",
    options: {},
    I: ForceRemoveAllEntitiesRequest,
    O: ForceRemoveAllEntitiesResponse,
  },
]);
