// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "dipstick/xcp/v1/protocol.proto" (package "dipstick.xcp.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../google/protobuf/timestamp";
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoRespPacket
 */
export interface CtoRespPacket {
  /**
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;
  /**
   * @generated from protobuf field: dipstick.xcp.v1.CtoRespPid pid = 2;
   */
  pid: CtoRespPid;
  /**
   * set if pid == XCP_PID_EV
   *
   * @generated from protobuf field: dipstick.xcp.v1.CtoEventCode event = 4;
   */
  event: CtoEventCode;
  /**
   * set if pid == XCP_PID_ERR
   *
   * @generated from protobuf field: dipstick.xcp.v1.CtoErrorCode error = 5;
   */
  error: CtoErrorCode;
  /**
   * remaining data
   *
   * @generated from protobuf field: bytes data = 3;
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoReq
 */
export interface CtoReq {
  /**
   * @generated from protobuf oneof: cto_req_data
   */
  ctoReqData:
    | {
        oneofKind: "connect";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoConnectReqData connect = 1;
         */
        connect: CtoConnectReqData;
      }
    | {
        oneofKind: "shortUpload";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoShortUploadReqData short_upload = 2;
         */
        shortUpload: CtoShortUploadReqData;
      }
    | {
        oneofKind: "shortDownload";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoShortDownloadReqData short_download = 3;
         */
        shortDownload: CtoShortDownloadReqData;
      }
    | {
        oneofKind: "setMta";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoSetMtaReqData set_mta = 4;
         */
        setMta: CtoSetMtaReqData;
      }
    | {
        oneofKind: "download";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoDownloadReqData download = 5;
         */
        download: CtoDownloadReqData;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoResp
 */
export interface CtoResp {
  /**
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 7;
   */
  timestamp?: Timestamp;
  /**
   * @generated from protobuf oneof: cto_resp_data
   */
  ctoRespData:
    | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoErrRespData error = 4;
         */
        error: CtoErrRespData;
      }
    | {
        oneofKind: "connect";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoConnectRespData connect = 1;
         */
        connect: CtoConnectRespData;
      }
    | {
        oneofKind: "shortUpload";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoShortUploadRespData short_upload = 2;
         */
        shortUpload: CtoShortUploadRespData;
      }
    | {
        oneofKind: "shortDownload";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoShortDownloadRespData short_download = 3;
         */
        shortDownload: CtoShortDownloadRespData;
      }
    | {
        oneofKind: "setMta";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoSetMtaRespData set_mta = 5;
         */
        setMta: CtoSetMtaRespData;
      }
    | {
        oneofKind: "download";
        /**
         * @generated from protobuf field: dipstick.xcp.v1.CtoDownloadRespData download = 6;
         */
        download: CtoDownloadRespData;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoErrRespData
 */
export interface CtoErrRespData {
  /**
   * @generated from protobuf field: dipstick.xcp.v1.CtoErrorCode error = 1;
   */
  error: CtoErrorCode;
  /**
   * @generated from protobuf field: bytes data = 2;
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoConnectReqData
 */
export interface CtoConnectReqData {
  /**
   * @generated from protobuf field: uint32 mode = 1;
   */
  mode: number;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoConnectRespData
 */
export interface CtoConnectRespData {
  /**
   * @generated from protobuf field: dipstick.xcp.v1.CtoResourceType resource = 1;
   */
  resource?: CtoResourceType;
  /**
   * @generated from protobuf field: dipstick.xcp.v1.CtoCommModeBasic comm_mode_basic = 2;
   */
  commModeBasic?: CtoCommModeBasic;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 max_cto = 3;
   */
  maxCto: number;
  /**
   * u16
   *
   * @generated from protobuf field: uint32 max_dto = 4;
   */
  maxDto: number;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 protocol_layer_version = 5;
   */
  protocolLayerVersion: number;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 transport_layer_version = 6;
   */
  transportLayerVersion: number;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoShortUploadReqData
 */
export interface CtoShortUploadReqData {
  /**
   * @generated from protobuf field: uint32 address = 1;
   */
  address: number;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 address_extension = 3;
   */
  addressExtension: number;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 length = 2;
   */
  length: number;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoShortUploadRespData
 */
export interface CtoShortUploadRespData {
  /**
   * @generated from protobuf field: bytes data = 1;
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoShortDownloadReqData
 */
export interface CtoShortDownloadReqData {
  /**
   * @generated from protobuf field: uint32 address = 1;
   */
  address: number;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 address_extension = 2;
   */
  addressExtension: number;
  /**
   * @generated from protobuf field: bytes data = 3;
   */
  data: Uint8Array;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoShortDownloadRespData
 */
export interface CtoShortDownloadRespData {}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoSetMtaReqData
 */
export interface CtoSetMtaReqData {
  /**
   * @generated from protobuf field: uint32 address = 1;
   */
  address: number;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 address_extension = 2;
   */
  addressExtension: number;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoSetMtaRespData
 */
export interface CtoSetMtaRespData {}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoDownloadReqData
 */
export interface CtoDownloadReqData {
  /**
   * @generated from protobuf field: bytes data = 1;
   */
  data: Uint8Array;
  /**
   * u8
   *
   * @generated from protobuf field: uint32 block_mode_length = 2;
   */
  blockModeLength: number;
  /**
   * @generated from protobuf field: bool last = 3;
   */
  last: boolean;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoDownloadRespData
 */
export interface CtoDownloadRespData {}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoResourceType
 */
export interface CtoResourceType {
  /**
   * @generated from protobuf field: bool dbg = 1;
   */
  dbg: boolean;
  /**
   * @generated from protobuf field: bool pgm = 2;
   */
  pgm: boolean;
  /**
   * @generated from protobuf field: bool stim = 3;
   */
  stim: boolean;
  /**
   * @generated from protobuf field: bool daq = 4;
   */
  daq: boolean;
  /**
   * @generated from protobuf field: bool calpag = 5;
   */
  calpag: boolean;
}
/**
 * @generated from protobuf message dipstick.xcp.v1.CtoCommModeBasic
 */
export interface CtoCommModeBasic {
  /**
   * @generated from protobuf field: bool optional = 1;
   */
  optional: boolean;
  /**
   * @generated from protobuf field: bool server_block_mode = 2;
   */
  serverBlockMode: boolean;
  /**
   * @generated from protobuf field: dipstick.xcp.v1.AddressGranularity address_granularity = 3;
   */
  addressGranularity: AddressGranularity;
  /**
   * @generated from protobuf field: dipstick.xcp.v1.ByteOrder byte_order = 4;
   */
  byteOrder: ByteOrder;
}
/**
 * @generated from protobuf enum dipstick.xcp.v1.CtoReqPid
 */
export enum CtoReqPid {
  /**
   * @generated from protobuf enum value: CTO_REQ_PID_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: CTO_REQ_PID_CONNECT = 1;
   */
  CONNECT = 1,
  /**
   * @generated from protobuf enum value: CTO_REQ_PID_SET_MTA = 2;
   */
  SET_MTA = 2,
  /**
   * @generated from protobuf enum value: CTO_REQ_PID_SHORT_UPLOAD = 3;
   */
  SHORT_UPLOAD = 3,
  /**
   * @generated from protobuf enum value: CTO_REQ_PID_SHORT_DOWNLOAD = 4;
   */
  SHORT_DOWNLOAD = 4,
  /**
   * @generated from protobuf enum value: CTO_REQ_PID_DOWNLOAD = 5;
   */
  DOWNLOAD = 5,
}
/**
 * @generated from protobuf enum dipstick.xcp.v1.CtoRespPid
 */
export enum CtoRespPid {
  /**
   * @generated from protobuf enum value: CTO_RESP_PID_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: CTO_RESP_PID_OK = 1;
   */
  OK = 1,
  /**
   * @generated from protobuf enum value: CTO_RESP_PID_ERR = 2;
   */
  ERR = 2,
  /**
   * @generated from protobuf enum value: CTO_RESP_PID_EV = 3;
   */
  EV = 3,
  /**
   * @generated from protobuf enum value: CTO_RESP_PID_SERV = 4;
   */
  SERV = 4,
}
/**
 * @generated from protobuf enum dipstick.xcp.v1.CtoEventCode
 */
export enum CtoEventCode {
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_RESUME_MODE = 1;
   */
  RESUME_MODE = 1,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_CLEAR_DAQ = 2;
   */
  CLEAR_DAQ = 2,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_STORE_DAQ = 3;
   */
  STORE_DAQ = 3,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_STORE_CAL = 4;
   */
  STORE_CAL = 4,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_CMD_PENDING = 5;
   */
  CMD_PENDING = 5,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_DAQ_OVERLOAD = 6;
   */
  DAQ_OVERLOAD = 6,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_SESSION_TERMINATED = 7;
   */
  SESSION_TERMINATED = 7,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_TIME_SYNC = 8;
   */
  TIME_SYNC = 8,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_STIM_TIMEOUT = 9;
   */
  STIM_TIMEOUT = 9,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_SLEEP = 10;
   */
  SLEEP = 10,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_WAKE_UP = 11;
   */
  WAKE_UP = 11,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_USER = 12;
   */
  USER = 12,
  /**
   * @generated from protobuf enum value: CTO_EVENT_CODE_TRANSPORT = 13;
   */
  TRANSPORT = 13,
}
/**
 * @generated from protobuf enum dipstick.xcp.v1.CtoErrorCode
 */
export enum CtoErrorCode {
  /**
   * @generated from protobuf enum value: CTO_ERROR_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * Command processor synchronization. S0
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_CMD_SYNCH = 1;
   */
  CMD_SYNCH = 1,
  /**
   * Command was not executed. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_CMD_BUSY = 2;
   */
  CMD_BUSY = 2,
  /**
   * Command rejected because DAQ is running. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_DAQ_ACTIVE = 3;
   */
  DAQ_ACTIVE = 3,
  /**
   * Command rejected because PGM is running. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_PGM_ACTIVE = 4;
   */
  PGM_ACTIVE = 4,
  /**
   * Unknown command or not implemented optional command. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_CMD_UNKNOWN = 5;
   */
  CMD_UNKNOWN = 5,
  /**
   * Command syntax invalid. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_CMD_SYNTAX = 6;
   */
  CMD_SYNTAX = 6,
  /**
   * Command syntax valid but command parameter(s) out of range. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_OUT_OF_RANGE = 7;
   */
  OUT_OF_RANGE = 7,
  /**
   * The memory location is write protected. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_WRITE_PROTECTED = 8;
   */
  WRITE_PROTECTED = 8,
  /**
   * The memory location is not accessible. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_ACCESS_DENIED = 9;
   */
  ACCESS_DENIED = 9,
  /**
   * Access denied, Seed & Key is required. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_ACCESS_LOCKED = 10;
   */
  ACCESS_LOCKED = 10,
  /**
   * Selected page not available. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_PAGE_NOT_VALID = 11;
   */
  PAGE_NOT_VALID = 11,
  /**
   * Selected page mode not available. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_MODE_NOT_VALID = 12;
   */
  MODE_NOT_VALID = 12,
  /**
   * Selected segment not valid. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_SEGMENT_NOT_VALID = 13;
   */
  SEGMENT_NOT_VALID = 13,
  /**
   * Sequence error. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_SEQUENCE = 14;
   */
  SEQUENCE = 14,
  /**
   * DAQ configuration not valid. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_DAQ_CONFIG = 15;
   */
  DAQ_CONFIG = 15,
  /**
   * Memory overflow error. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_MEMORY_OVERFLOW = 16;
   */
  MEMORY_OVERFLOW = 16,
  /**
   * Generic error. S2
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_GENERIC = 17;
   */
  GENERIC = 17,
  /**
   * The slave internal program verify routine detects an error. S3 NEW IN 1.1
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_VERIFY = 18;
   */
  VERIFY = 18,
  /**
   * Access to the requested resource is temporary not possible. S3
   *
   * @generated from protobuf enum value: CTO_ERROR_CODE_RESOURCE_TEMPORARY_NOT_ACCESSIBLE = 19;
   */
  RESOURCE_TEMPORARY_NOT_ACCESSIBLE = 19,
}
/**
 * @generated from protobuf enum dipstick.xcp.v1.AddressGranularity
 */
export enum AddressGranularity {
  /**
   * @generated from protobuf enum value: ADDRESS_GRANULARITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: ADDRESS_GRANULARITY_BYTE = 1;
   */
  BYTE = 1,
  /**
   * @generated from protobuf enum value: ADDRESS_GRANULARITY_WORD = 2;
   */
  WORD = 2,
  /**
   * @generated from protobuf enum value: ADDRESS_GRANULARITY_DWORD = 3;
   */
  DWORD = 3,
  /**
   * @generated from protobuf enum value: ADDRESS_GRANULARITY_RESERVED = 4;
   */
  RESERVED = 4,
}
/**
 * @generated from protobuf enum dipstick.xcp.v1.ByteOrder
 */
export enum ByteOrder {
  /**
   * @generated from protobuf enum value: BYTE_ORDER_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: BYTE_ORDER_LITTLE_ENDIAN = 1;
   */
  LITTLE_ENDIAN = 1,
  /**
   * @generated from protobuf enum value: BYTE_ORDER_BIG_ENDIAN = 2;
   */
  BIG_ENDIAN = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class CtoRespPacket$Type extends MessageType<CtoRespPacket> {
  constructor() {
    super("dipstick.xcp.v1.CtoRespPacket", [
      { no: 1, name: "timestamp", kind: "message", T: () => Timestamp },
      {
        no: 2,
        name: "pid",
        kind: "enum",
        T: () => ["dipstick.xcp.v1.CtoRespPid", CtoRespPid, "CTO_RESP_PID_"],
      },
      {
        no: 4,
        name: "event",
        kind: "enum",
        T: () => [
          "dipstick.xcp.v1.CtoEventCode",
          CtoEventCode,
          "CTO_EVENT_CODE_",
        ],
      },
      {
        no: 5,
        name: "error",
        kind: "enum",
        T: () => [
          "dipstick.xcp.v1.CtoErrorCode",
          CtoErrorCode,
          "CTO_ERROR_CODE_",
        ],
      },
      { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<CtoRespPacket>): CtoRespPacket {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.pid = 0;
    message.event = 0;
    message.error = 0;
    message.data = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<CtoRespPacket>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoRespPacket,
  ): CtoRespPacket {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Timestamp timestamp */ 1:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        case /* dipstick.xcp.v1.CtoRespPid pid */ 2:
          message.pid = reader.int32();
          break;
        case /* dipstick.xcp.v1.CtoEventCode event */ 4:
          message.event = reader.int32();
          break;
        case /* dipstick.xcp.v1.CtoErrorCode error */ 5:
          message.error = reader.int32();
          break;
        case /* bytes data */ 3:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoRespPacket,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.protobuf.Timestamp timestamp = 1; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoRespPid pid = 2; */
    if (message.pid !== 0) writer.tag(2, WireType.Varint).int32(message.pid);
    /* dipstick.xcp.v1.CtoEventCode event = 4; */
    if (message.event !== 0)
      writer.tag(4, WireType.Varint).int32(message.event);
    /* dipstick.xcp.v1.CtoErrorCode error = 5; */
    if (message.error !== 0)
      writer.tag(5, WireType.Varint).int32(message.error);
    /* bytes data = 3; */
    if (message.data.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoRespPacket
 */
export const CtoRespPacket = new CtoRespPacket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoReq$Type extends MessageType<CtoReq> {
  constructor() {
    super("dipstick.xcp.v1.CtoReq", [
      {
        no: 1,
        name: "connect",
        kind: "message",
        oneof: "ctoReqData",
        T: () => CtoConnectReqData,
      },
      {
        no: 2,
        name: "short_upload",
        kind: "message",
        oneof: "ctoReqData",
        T: () => CtoShortUploadReqData,
      },
      {
        no: 3,
        name: "short_download",
        kind: "message",
        oneof: "ctoReqData",
        T: () => CtoShortDownloadReqData,
      },
      {
        no: 4,
        name: "set_mta",
        kind: "message",
        oneof: "ctoReqData",
        T: () => CtoSetMtaReqData,
      },
      {
        no: 5,
        name: "download",
        kind: "message",
        oneof: "ctoReqData",
        T: () => CtoDownloadReqData,
      },
    ]);
  }
  create(value?: PartialMessage<CtoReq>): CtoReq {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.ctoReqData = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<CtoReq>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoReq,
  ): CtoReq {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dipstick.xcp.v1.CtoConnectReqData connect */ 1:
          message.ctoReqData = {
            oneofKind: "connect",
            connect: CtoConnectReqData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoReqData as any).connect,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoShortUploadReqData short_upload */ 2:
          message.ctoReqData = {
            oneofKind: "shortUpload",
            shortUpload: CtoShortUploadReqData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoReqData as any).shortUpload,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoShortDownloadReqData short_download */ 3:
          message.ctoReqData = {
            oneofKind: "shortDownload",
            shortDownload: CtoShortDownloadReqData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoReqData as any).shortDownload,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoSetMtaReqData set_mta */ 4:
          message.ctoReqData = {
            oneofKind: "setMta",
            setMta: CtoSetMtaReqData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoReqData as any).setMta,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoDownloadReqData download */ 5:
          message.ctoReqData = {
            oneofKind: "download",
            download: CtoDownloadReqData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoReqData as any).download,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoReq,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* dipstick.xcp.v1.CtoConnectReqData connect = 1; */
    if (message.ctoReqData.oneofKind === "connect")
      CtoConnectReqData.internalBinaryWrite(
        message.ctoReqData.connect,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoShortUploadReqData short_upload = 2; */
    if (message.ctoReqData.oneofKind === "shortUpload")
      CtoShortUploadReqData.internalBinaryWrite(
        message.ctoReqData.shortUpload,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoShortDownloadReqData short_download = 3; */
    if (message.ctoReqData.oneofKind === "shortDownload")
      CtoShortDownloadReqData.internalBinaryWrite(
        message.ctoReqData.shortDownload,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoSetMtaReqData set_mta = 4; */
    if (message.ctoReqData.oneofKind === "setMta")
      CtoSetMtaReqData.internalBinaryWrite(
        message.ctoReqData.setMta,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoDownloadReqData download = 5; */
    if (message.ctoReqData.oneofKind === "download")
      CtoDownloadReqData.internalBinaryWrite(
        message.ctoReqData.download,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoReq
 */
export const CtoReq = new CtoReq$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoResp$Type extends MessageType<CtoResp> {
  constructor() {
    super("dipstick.xcp.v1.CtoResp", [
      { no: 7, name: "timestamp", kind: "message", T: () => Timestamp },
      {
        no: 4,
        name: "error",
        kind: "message",
        oneof: "ctoRespData",
        T: () => CtoErrRespData,
      },
      {
        no: 1,
        name: "connect",
        kind: "message",
        oneof: "ctoRespData",
        T: () => CtoConnectRespData,
      },
      {
        no: 2,
        name: "short_upload",
        kind: "message",
        oneof: "ctoRespData",
        T: () => CtoShortUploadRespData,
      },
      {
        no: 3,
        name: "short_download",
        kind: "message",
        oneof: "ctoRespData",
        T: () => CtoShortDownloadRespData,
      },
      {
        no: 5,
        name: "set_mta",
        kind: "message",
        oneof: "ctoRespData",
        T: () => CtoSetMtaRespData,
      },
      {
        no: 6,
        name: "download",
        kind: "message",
        oneof: "ctoRespData",
        T: () => CtoDownloadRespData,
      },
    ]);
  }
  create(value?: PartialMessage<CtoResp>): CtoResp {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.ctoRespData = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<CtoResp>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoResp,
  ): CtoResp {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Timestamp timestamp */ 7:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        case /* dipstick.xcp.v1.CtoErrRespData error */ 4:
          message.ctoRespData = {
            oneofKind: "error",
            error: CtoErrRespData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoRespData as any).error,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoConnectRespData connect */ 1:
          message.ctoRespData = {
            oneofKind: "connect",
            connect: CtoConnectRespData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoRespData as any).connect,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoShortUploadRespData short_upload */ 2:
          message.ctoRespData = {
            oneofKind: "shortUpload",
            shortUpload: CtoShortUploadRespData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoRespData as any).shortUpload,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoShortDownloadRespData short_download */ 3:
          message.ctoRespData = {
            oneofKind: "shortDownload",
            shortDownload: CtoShortDownloadRespData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoRespData as any).shortDownload,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoSetMtaRespData set_mta */ 5:
          message.ctoRespData = {
            oneofKind: "setMta",
            setMta: CtoSetMtaRespData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoRespData as any).setMta,
            ),
          };
          break;
        case /* dipstick.xcp.v1.CtoDownloadRespData download */ 6:
          message.ctoRespData = {
            oneofKind: "download",
            download: CtoDownloadRespData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.ctoRespData as any).download,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoResp,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.protobuf.Timestamp timestamp = 7; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoErrRespData error = 4; */
    if (message.ctoRespData.oneofKind === "error")
      CtoErrRespData.internalBinaryWrite(
        message.ctoRespData.error,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoConnectRespData connect = 1; */
    if (message.ctoRespData.oneofKind === "connect")
      CtoConnectRespData.internalBinaryWrite(
        message.ctoRespData.connect,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoShortUploadRespData short_upload = 2; */
    if (message.ctoRespData.oneofKind === "shortUpload")
      CtoShortUploadRespData.internalBinaryWrite(
        message.ctoRespData.shortUpload,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoShortDownloadRespData short_download = 3; */
    if (message.ctoRespData.oneofKind === "shortDownload")
      CtoShortDownloadRespData.internalBinaryWrite(
        message.ctoRespData.shortDownload,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoSetMtaRespData set_mta = 5; */
    if (message.ctoRespData.oneofKind === "setMta")
      CtoSetMtaRespData.internalBinaryWrite(
        message.ctoRespData.setMta,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoDownloadRespData download = 6; */
    if (message.ctoRespData.oneofKind === "download")
      CtoDownloadRespData.internalBinaryWrite(
        message.ctoRespData.download,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoResp
 */
export const CtoResp = new CtoResp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoErrRespData$Type extends MessageType<CtoErrRespData> {
  constructor() {
    super("dipstick.xcp.v1.CtoErrRespData", [
      {
        no: 1,
        name: "error",
        kind: "enum",
        T: () => [
          "dipstick.xcp.v1.CtoErrorCode",
          CtoErrorCode,
          "CTO_ERROR_CODE_",
        ],
      },
      { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<CtoErrRespData>): CtoErrRespData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.error = 0;
    message.data = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<CtoErrRespData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoErrRespData,
  ): CtoErrRespData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dipstick.xcp.v1.CtoErrorCode error */ 1:
          message.error = reader.int32();
          break;
        case /* bytes data */ 2:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoErrRespData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* dipstick.xcp.v1.CtoErrorCode error = 1; */
    if (message.error !== 0)
      writer.tag(1, WireType.Varint).int32(message.error);
    /* bytes data = 2; */
    if (message.data.length)
      writer.tag(2, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoErrRespData
 */
export const CtoErrRespData = new CtoErrRespData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoConnectReqData$Type extends MessageType<CtoConnectReqData> {
  constructor() {
    super("dipstick.xcp.v1.CtoConnectReqData", [
      { no: 1, name: "mode", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<CtoConnectReqData>): CtoConnectReqData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.mode = 0;
    if (value !== undefined)
      reflectionMergePartial<CtoConnectReqData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoConnectReqData,
  ): CtoConnectReqData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 mode */ 1:
          message.mode = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoConnectReqData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 mode = 1; */
    if (message.mode !== 0) writer.tag(1, WireType.Varint).uint32(message.mode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoConnectReqData
 */
export const CtoConnectReqData = new CtoConnectReqData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoConnectRespData$Type extends MessageType<CtoConnectRespData> {
  constructor() {
    super("dipstick.xcp.v1.CtoConnectRespData", [
      { no: 1, name: "resource", kind: "message", T: () => CtoResourceType },
      {
        no: 2,
        name: "comm_mode_basic",
        kind: "message",
        T: () => CtoCommModeBasic,
      },
      { no: 3, name: "max_cto", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      { no: 4, name: "max_dto", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      {
        no: 5,
        name: "protocol_layer_version",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 6,
        name: "transport_layer_version",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CtoConnectRespData>): CtoConnectRespData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.maxCto = 0;
    message.maxDto = 0;
    message.protocolLayerVersion = 0;
    message.transportLayerVersion = 0;
    if (value !== undefined)
      reflectionMergePartial<CtoConnectRespData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoConnectRespData,
  ): CtoConnectRespData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* dipstick.xcp.v1.CtoResourceType resource */ 1:
          message.resource = CtoResourceType.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.resource,
          );
          break;
        case /* dipstick.xcp.v1.CtoCommModeBasic comm_mode_basic */ 2:
          message.commModeBasic = CtoCommModeBasic.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.commModeBasic,
          );
          break;
        case /* uint32 max_cto */ 3:
          message.maxCto = reader.uint32();
          break;
        case /* uint32 max_dto */ 4:
          message.maxDto = reader.uint32();
          break;
        case /* uint32 protocol_layer_version */ 5:
          message.protocolLayerVersion = reader.uint32();
          break;
        case /* uint32 transport_layer_version */ 6:
          message.transportLayerVersion = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoConnectRespData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* dipstick.xcp.v1.CtoResourceType resource = 1; */
    if (message.resource)
      CtoResourceType.internalBinaryWrite(
        message.resource,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* dipstick.xcp.v1.CtoCommModeBasic comm_mode_basic = 2; */
    if (message.commModeBasic)
      CtoCommModeBasic.internalBinaryWrite(
        message.commModeBasic,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* uint32 max_cto = 3; */
    if (message.maxCto !== 0)
      writer.tag(3, WireType.Varint).uint32(message.maxCto);
    /* uint32 max_dto = 4; */
    if (message.maxDto !== 0)
      writer.tag(4, WireType.Varint).uint32(message.maxDto);
    /* uint32 protocol_layer_version = 5; */
    if (message.protocolLayerVersion !== 0)
      writer.tag(5, WireType.Varint).uint32(message.protocolLayerVersion);
    /* uint32 transport_layer_version = 6; */
    if (message.transportLayerVersion !== 0)
      writer.tag(6, WireType.Varint).uint32(message.transportLayerVersion);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoConnectRespData
 */
export const CtoConnectRespData = new CtoConnectRespData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoShortUploadReqData$Type extends MessageType<CtoShortUploadReqData> {
  constructor() {
    super("dipstick.xcp.v1.CtoShortUploadReqData", [
      { no: 1, name: "address", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      {
        no: 3,
        name: "address_extension",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 2, name: "length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
    ]);
  }
  create(value?: PartialMessage<CtoShortUploadReqData>): CtoShortUploadReqData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.address = 0;
    message.addressExtension = 0;
    message.length = 0;
    if (value !== undefined)
      reflectionMergePartial<CtoShortUploadReqData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoShortUploadReqData,
  ): CtoShortUploadReqData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 address */ 1:
          message.address = reader.uint32();
          break;
        case /* uint32 address_extension */ 3:
          message.addressExtension = reader.uint32();
          break;
        case /* uint32 length */ 2:
          message.length = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoShortUploadReqData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 address = 1; */
    if (message.address !== 0)
      writer.tag(1, WireType.Varint).uint32(message.address);
    /* uint32 address_extension = 3; */
    if (message.addressExtension !== 0)
      writer.tag(3, WireType.Varint).uint32(message.addressExtension);
    /* uint32 length = 2; */
    if (message.length !== 0)
      writer.tag(2, WireType.Varint).uint32(message.length);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoShortUploadReqData
 */
export const CtoShortUploadReqData = new CtoShortUploadReqData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoShortUploadRespData$Type extends MessageType<CtoShortUploadRespData> {
  constructor() {
    super("dipstick.xcp.v1.CtoShortUploadRespData", [
      { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(
    value?: PartialMessage<CtoShortUploadRespData>,
  ): CtoShortUploadRespData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.data = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<CtoShortUploadRespData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoShortUploadRespData,
  ): CtoShortUploadRespData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */ 1:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoShortUploadRespData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes data = 1; */
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoShortUploadRespData
 */
export const CtoShortUploadRespData = new CtoShortUploadRespData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoShortDownloadReqData$Type extends MessageType<CtoShortDownloadReqData> {
  constructor() {
    super("dipstick.xcp.v1.CtoShortDownloadReqData", [
      { no: 1, name: "address", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      {
        no: 2,
        name: "address_extension",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(
    value?: PartialMessage<CtoShortDownloadReqData>,
  ): CtoShortDownloadReqData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.address = 0;
    message.addressExtension = 0;
    message.data = new Uint8Array(0);
    if (value !== undefined)
      reflectionMergePartial<CtoShortDownloadReqData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoShortDownloadReqData,
  ): CtoShortDownloadReqData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 address */ 1:
          message.address = reader.uint32();
          break;
        case /* uint32 address_extension */ 2:
          message.addressExtension = reader.uint32();
          break;
        case /* bytes data */ 3:
          message.data = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoShortDownloadReqData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 address = 1; */
    if (message.address !== 0)
      writer.tag(1, WireType.Varint).uint32(message.address);
    /* uint32 address_extension = 2; */
    if (message.addressExtension !== 0)
      writer.tag(2, WireType.Varint).uint32(message.addressExtension);
    /* bytes data = 3; */
    if (message.data.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.data);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoShortDownloadReqData
 */
export const CtoShortDownloadReqData = new CtoShortDownloadReqData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoShortDownloadRespData$Type extends MessageType<CtoShortDownloadRespData> {
  constructor() {
    super("dipstick.xcp.v1.CtoShortDownloadRespData", []);
  }
  create(
    value?: PartialMessage<CtoShortDownloadRespData>,
  ): CtoShortDownloadRespData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CtoShortDownloadRespData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoShortDownloadRespData,
  ): CtoShortDownloadRespData {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CtoShortDownloadRespData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoShortDownloadRespData
 */
export const CtoShortDownloadRespData = new CtoShortDownloadRespData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoSetMtaReqData$Type extends MessageType<CtoSetMtaReqData> {
  constructor() {
    super("dipstick.xcp.v1.CtoSetMtaReqData", [
      { no: 1, name: "address", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      {
        no: 2,
        name: "address_extension",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<CtoSetMtaReqData>): CtoSetMtaReqData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.address = 0;
    message.addressExtension = 0;
    if (value !== undefined)
      reflectionMergePartial<CtoSetMtaReqData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoSetMtaReqData,
  ): CtoSetMtaReqData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint32 address */ 1:
          message.address = reader.uint32();
          break;
        case /* uint32 address_extension */ 2:
          message.addressExtension = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoSetMtaReqData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 address = 1; */
    if (message.address !== 0)
      writer.tag(1, WireType.Varint).uint32(message.address);
    /* uint32 address_extension = 2; */
    if (message.addressExtension !== 0)
      writer.tag(2, WireType.Varint).uint32(message.addressExtension);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoSetMtaReqData
 */
export const CtoSetMtaReqData = new CtoSetMtaReqData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoSetMtaRespData$Type extends MessageType<CtoSetMtaRespData> {
  constructor() {
    super("dipstick.xcp.v1.CtoSetMtaRespData", []);
  }
  create(value?: PartialMessage<CtoSetMtaRespData>): CtoSetMtaRespData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CtoSetMtaRespData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoSetMtaRespData,
  ): CtoSetMtaRespData {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CtoSetMtaRespData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoSetMtaRespData
 */
export const CtoSetMtaRespData = new CtoSetMtaRespData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoDownloadReqData$Type extends MessageType<CtoDownloadReqData> {
  constructor() {
    super("dipstick.xcp.v1.CtoDownloadReqData", [
      { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "block_mode_length",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      { no: 3, name: "last", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<CtoDownloadReqData>): CtoDownloadReqData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.data = new Uint8Array(0);
    message.blockModeLength = 0;
    message.last = false;
    if (value !== undefined)
      reflectionMergePartial<CtoDownloadReqData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoDownloadReqData,
  ): CtoDownloadReqData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bytes data */ 1:
          message.data = reader.bytes();
          break;
        case /* uint32 block_mode_length */ 2:
          message.blockModeLength = reader.uint32();
          break;
        case /* bool last */ 3:
          message.last = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoDownloadReqData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes data = 1; */
    if (message.data.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.data);
    /* uint32 block_mode_length = 2; */
    if (message.blockModeLength !== 0)
      writer.tag(2, WireType.Varint).uint32(message.blockModeLength);
    /* bool last = 3; */
    if (message.last !== false)
      writer.tag(3, WireType.Varint).bool(message.last);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoDownloadReqData
 */
export const CtoDownloadReqData = new CtoDownloadReqData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoDownloadRespData$Type extends MessageType<CtoDownloadRespData> {
  constructor() {
    super("dipstick.xcp.v1.CtoDownloadRespData", []);
  }
  create(value?: PartialMessage<CtoDownloadRespData>): CtoDownloadRespData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<CtoDownloadRespData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoDownloadRespData,
  ): CtoDownloadRespData {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CtoDownloadRespData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoDownloadRespData
 */
export const CtoDownloadRespData = new CtoDownloadRespData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoResourceType$Type extends MessageType<CtoResourceType> {
  constructor() {
    super("dipstick.xcp.v1.CtoResourceType", [
      { no: 1, name: "dbg", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 2, name: "pgm", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: "stim", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "daq", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 5, name: "calpag", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<CtoResourceType>): CtoResourceType {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.dbg = false;
    message.pgm = false;
    message.stim = false;
    message.daq = false;
    message.calpag = false;
    if (value !== undefined)
      reflectionMergePartial<CtoResourceType>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoResourceType,
  ): CtoResourceType {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool dbg */ 1:
          message.dbg = reader.bool();
          break;
        case /* bool pgm */ 2:
          message.pgm = reader.bool();
          break;
        case /* bool stim */ 3:
          message.stim = reader.bool();
          break;
        case /* bool daq */ 4:
          message.daq = reader.bool();
          break;
        case /* bool calpag */ 5:
          message.calpag = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoResourceType,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool dbg = 1; */
    if (message.dbg !== false) writer.tag(1, WireType.Varint).bool(message.dbg);
    /* bool pgm = 2; */
    if (message.pgm !== false) writer.tag(2, WireType.Varint).bool(message.pgm);
    /* bool stim = 3; */
    if (message.stim !== false)
      writer.tag(3, WireType.Varint).bool(message.stim);
    /* bool daq = 4; */
    if (message.daq !== false) writer.tag(4, WireType.Varint).bool(message.daq);
    /* bool calpag = 5; */
    if (message.calpag !== false)
      writer.tag(5, WireType.Varint).bool(message.calpag);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoResourceType
 */
export const CtoResourceType = new CtoResourceType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CtoCommModeBasic$Type extends MessageType<CtoCommModeBasic> {
  constructor() {
    super("dipstick.xcp.v1.CtoCommModeBasic", [
      { no: 1, name: "optional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "server_block_mode",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 3,
        name: "address_granularity",
        kind: "enum",
        T: () => [
          "dipstick.xcp.v1.AddressGranularity",
          AddressGranularity,
          "ADDRESS_GRANULARITY_",
        ],
      },
      {
        no: 4,
        name: "byte_order",
        kind: "enum",
        T: () => ["dipstick.xcp.v1.ByteOrder", ByteOrder, "BYTE_ORDER_"],
      },
    ]);
  }
  create(value?: PartialMessage<CtoCommModeBasic>): CtoCommModeBasic {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.optional = false;
    message.serverBlockMode = false;
    message.addressGranularity = 0;
    message.byteOrder = 0;
    if (value !== undefined)
      reflectionMergePartial<CtoCommModeBasic>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CtoCommModeBasic,
  ): CtoCommModeBasic {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool optional */ 1:
          message.optional = reader.bool();
          break;
        case /* bool server_block_mode */ 2:
          message.serverBlockMode = reader.bool();
          break;
        case /* dipstick.xcp.v1.AddressGranularity address_granularity */ 3:
          message.addressGranularity = reader.int32();
          break;
        case /* dipstick.xcp.v1.ByteOrder byte_order */ 4:
          message.byteOrder = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CtoCommModeBasic,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool optional = 1; */
    if (message.optional !== false)
      writer.tag(1, WireType.Varint).bool(message.optional);
    /* bool server_block_mode = 2; */
    if (message.serverBlockMode !== false)
      writer.tag(2, WireType.Varint).bool(message.serverBlockMode);
    /* dipstick.xcp.v1.AddressGranularity address_granularity = 3; */
    if (message.addressGranularity !== 0)
      writer.tag(3, WireType.Varint).int32(message.addressGranularity);
    /* dipstick.xcp.v1.ByteOrder byte_order = 4; */
    if (message.byteOrder !== 0)
      writer.tag(4, WireType.Varint).int32(message.byteOrder);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message dipstick.xcp.v1.CtoCommModeBasic
 */
export const CtoCommModeBasic = new CtoCommModeBasic$Type();
